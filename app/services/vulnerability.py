from typing import List
from fastapi import UploadFile, HTTPException
from sqlalchemy.orm import Session
import pandas as pd
from datetime import datetime
import hashlib
import json

from app.models.vulnerability import Vulnerability, VulnerabilityStatusHistory, ScanTemplate
from app.services import template as template_service


def get_months(db: Session) -> List[str]:
    result = db.query(Vulnerability.reference_month).distinct().all()
    return [row[0] for row in result]


def generate_vuln_hash(ip: str, hostname: str, nvt_name: str, cves: str) -> str:
    """Gera hash determinístico para identificar vulnerabilidades únicas"""
    # Normaliza os dados para garantir consistência
    ip = str(ip).strip()
    hostname = str(hostname).strip() if hostname else ""
    nvt_name = str(nvt_name).strip()
    cves = str(cves).strip() if cves else ""
    
    # Ordena CVEs para garantir consistência
    if cves:
        cve_list = sorted([cve.strip() for cve in cves.split(',')])
        cves = ','.join(cve_list)
    
    # Cria string para hash
    hash_string = f"{ip}|{hostname}|{nvt_name}|{cves}"
    return hashlib.sha256(hash_string.encode()).hexdigest()


def determine_vulnerability_status(db: Session, vuln_hash: str, reference_month: str) -> str:
    """Determina o status da vulnerabilidade baseado no histórico"""
    # Busca vulnerabilidades anteriores
    previous_vulns = db.query(Vulnerability).filter(
        Vulnerability.vuln_hash == vuln_hash,
        Vulnerability.reference_month != reference_month
    ).order_by(Vulnerability.reference_month.desc()).all()
    
    if not previous_vulns:
        return "new"
    
    # Busca o mês mais recente anterior
    latest_month = max([v.reference_month for v in previous_vulns])
    
    # Verifica se existia no mês anterior
    previous_month_vuln = db.query(Vulnerability).filter(
        Vulnerability.vuln_hash == vuln_hash,
        Vulnerability.reference_month == latest_month
    ).first()
    
    if previous_month_vuln:
        return "ongoing"
    else:
        return "reopened"


def save_csv(db: Session, file: UploadFile, reference_month: str, template_id: int):
    """Salva CSV usando template para mapeamento"""
    # Busca template
    template = template_service.get_template(db, template_id)
    if not template:
        raise HTTPException(status_code=404, detail="Template not found")
    
    df = pd.read_csv(file.file)
    
    # Aplica mapeamento de colunas
    column_mapping = template.column_mapping
    severity_map = template.severity_map
    
    # Renomeia colunas conforme template
    df = df.rename(columns=column_mapping)
    
    # Lista para armazenar hashes processados neste upload
    processed_hashes = set()
    
    for _, row in df.iterrows():
        # Extrai dados das colunas mapeadas
        ip = str(row.get("ip", "")).strip()
        hostname = str(row.get("hostname", "")).strip()
        nvt_name = str(row.get("nvt_name", "")).strip()
        cves = str(row.get("cves", "")).strip()
        cvss = row.get("cvss")
        
        # Normaliza severidade
        raw_severity = str(row.get("severity", "")).strip().lower()
        severity = severity_map.get(raw_severity, raw_severity)
        
        # Gera hash
        vuln_hash = generate_vuln_hash(ip, hostname, nvt_name, cves)
        
        # Determina status
        status = determine_vulnerability_status(db, vuln_hash, reference_month)
        
        # Cria vulnerabilidade
        vuln = Vulnerability(
            ip=ip,
            hostname=hostname if hostname else None,
            nvt_name=nvt_name,
            severity=severity,
            cvss=float(cvss) if cvss is not None else None,
            cves=cves if cves else None,
            reference_month=reference_month,
            vuln_hash=vuln_hash,
            status=status
        )
        
        db.add(vuln)
        processed_hashes.add(vuln_hash)
    
    # Registra histórico de status
    for vuln_hash in processed_hashes:
        status = determine_vulnerability_status(db, vuln_hash, reference_month)
        history = VulnerabilityStatusHistory(
            vuln_hash=vuln_hash,
            month=reference_month,
            status=status
        )
        db.add(history)
    
    # Marca vulnerabilidades fechadas (que existiam no mês anterior mas não neste)
    previous_month_vulns = db.query(Vulnerability).filter(
        Vulnerability.reference_month != reference_month
    ).all()
    
    for prev_vuln in previous_month_vulns:
        if prev_vuln.vuln_hash not in processed_hashes:
            # Verifica se não já foi marcada como fechada
            existing_closed = db.query(VulnerabilityStatusHistory).filter(
                VulnerabilityStatusHistory.vuln_hash == prev_vuln.vuln_hash,
                VulnerabilityStatusHistory.month == reference_month,
                VulnerabilityStatusHistory.status == "closed"
            ).first()
            
            if not existing_closed:
                history = VulnerabilityStatusHistory(
                    vuln_hash=prev_vuln.vuln_hash,
                    month=reference_month,
                    status="closed"
                )
                db.add(history)
    
    db.commit()


def delete_by_month(db: Session, month: str):
    # Remove vulnerabilidades do mês
    db.query(Vulnerability).filter(Vulnerability.reference_month == month).delete()
    # Remove histórico do mês
    db.query(VulnerabilityStatusHistory).filter(VulnerabilityStatusHistory.month == month).delete()
    db.commit()


def delete_all(db: Session):
    db.query(Vulnerability).delete()
    db.query(VulnerabilityStatusHistory).delete()
    db.commit()


def list_vulnerabilities(db: Session, skip: int = 0, limit: int = 100):
    return db.query(Vulnerability).offset(skip).limit(limit).all()


def get_vulnerability_history(db: Session, vuln_hash: str):
    """Retorna histórico de uma vulnerabilidade específica"""
    return db.query(VulnerabilityStatusHistory).filter(
        VulnerabilityStatusHistory.vuln_hash == vuln_hash
    ).order_by(VulnerabilityStatusHistory.month).all()
