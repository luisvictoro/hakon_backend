from typing import List, Dict, Any
from fastapi import UploadFile, HTTPException
from sqlalchemy.orm import Session
from sqlalchemy import func, desc
import pandas as pd
from datetime import datetime
import hashlib
import json

from app.models.vulnerability import Vulnerability, VulnerabilityStatusHistory, ScanTemplate
from app.services import template as template_service


def get_months(db: Session) -> List[str]:
    result = db.query(Vulnerability.reference_month).distinct().all()
    return [row[0] for row in result]


def generate_vuln_hash(ip: str, hostname: str, nvt_name: str, cves: str) -> str:
    """Gera hash determinístico para identificar vulnerabilidades únicas"""
    # Normaliza os dados para garantir consistência
    ip = str(ip).strip()
    hostname = str(hostname).strip() if hostname else ""
    nvt_name = str(nvt_name).strip()
    cves = str(cves).strip() if cves else ""
    
    # Ordena CVEs para garantir consistência
    if cves:
        cve_list = sorted([cve.strip() for cve in cves.split(',')])
        cves = ','.join(cve_list)
    
    # Cria string para hash
    hash_string = f"{ip}|{hostname}|{nvt_name}|{cves}"
    return hashlib.sha256(hash_string.encode()).hexdigest()


def determine_vulnerability_status(db: Session, vuln_hash: str, reference_month: str) -> str:
    """Determina o status da vulnerabilidade baseado no histórico"""
    # Busca vulnerabilidades anteriores
    previous_vulns = db.query(Vulnerability).filter(
        Vulnerability.vuln_hash == vuln_hash,
        Vulnerability.reference_month != reference_month
    ).order_by(Vulnerability.reference_month.desc()).all()
    
    if not previous_vulns:
        return "new"
    
    # Busca o mês mais recente anterior
    latest_month = max([v.reference_month for v in previous_vulns])
    
    # Verifica se existia no mês anterior
    previous_month_vuln = db.query(Vulnerability).filter(
        Vulnerability.vuln_hash == vuln_hash,
        Vulnerability.reference_month == latest_month
    ).first()
    
    if previous_month_vuln:
        return "ongoing"
    else:
        return "reopened"


def save_csv(db: Session, file: UploadFile, reference_month: str, template_id: int):
    """Salva CSV usando template para mapeamento"""
    # Busca template
    template = template_service.get_template(db, template_id)
    if not template:
        raise HTTPException(status_code=404, detail="Template not found")

    try:
        df = pd.read_csv(file.file)
        print(f"CSV carregado com {len(df)} linhas e colunas: {list(df.columns)}")
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Erro ao ler CSV: {str(e)}")
    
    # Aplica mapeamento de colunas
    column_mapping = template.column_mapping
    severity_map = template.severity_map
    
    # Renomeia colunas conforme template
    df = df.rename(columns=column_mapping)
    
    # Lista para armazenar hashes processados neste upload
    processed_hashes = set()
    processed_count = 0
    skipped_count = 0
    
    print(f"Processando {len(df)} linhas do CSV...")
    
    for index, row in df.iterrows():
        try:
            # Extrai dados das colunas mapeadas - corrigido para extrair valores corretamente
            ip = str(row["ip"]).strip() if pd.notna(row["ip"]) else ""
            hostname = str(row["hostname"]).strip() if pd.notna(row["hostname"]) else ""
            nvt_name = str(row["nvt_name"]).strip() if pd.notna(row["nvt_name"]) else ""
            cves = str(row["cves"]).strip() if pd.notna(row["cves"]) else ""
            cvss = row["cvss"] if pd.notna(row["cvss"]) else None
            
            # Normaliza severidade
            raw_severity = str(row["severity"]).strip().lower() if pd.notna(row["severity"]) else ""
            severity = severity_map.get(raw_severity, raw_severity)
            
            # Gera hash
            vuln_hash = generate_vuln_hash(ip, hostname, nvt_name, cves)
            
            # Determina status
            status = determine_vulnerability_status(db, vuln_hash, reference_month)
            
            # Valida e limpa os dados antes de criar a vulnerabilidade
            if not ip or ip == "nan" or len(ip) > 45:
                skipped_count += 1
                continue  # Pula registros com IP inválido
            
            if not nvt_name or nvt_name == "nan":
                skipped_count += 1
                continue  # Pula registros sem nome de vulnerabilidade
            
            # Limita tamanho dos campos conforme definido no modelo
            ip = ip[:45] if len(ip) > 45 else ip
            hostname = hostname[:255] if hostname and len(hostname) > 255 else hostname
            nvt_name = nvt_name[:1000] if len(nvt_name) > 1000 else nvt_name  # Limite para TEXT
            severity = severity[:20] if len(severity) > 20 else severity
            
            # Converte CVSS para float se possível
            try:
                cvss_float = float(cvss) if cvss is not None and cvss != "nan" else None
            except (ValueError, TypeError):
                cvss_float = None
            
            # Cria vulnerabilidade
            vuln = Vulnerability(
                ip=ip,
                hostname=hostname if hostname and hostname != "nan" else None,
                nvt_name=nvt_name,
                severity=severity,
                cvss=cvss_float,
                cves=cves if cves and cves != "nan" else None,
                reference_month=reference_month,
                vuln_hash=vuln_hash,
                status=status
            )
            
            db.add(vuln)
            processed_hashes.add(vuln_hash)
            processed_count += 1
            
        except Exception as e:
            print(f"Erro ao processar linha {index}: {e}")
            skipped_count += 1
            continue
    
    print(f"Processamento concluído: {processed_count} processadas, {skipped_count} ignoradas")
    
    # Registra histórico de status
    for vuln_hash in processed_hashes:
        status = determine_vulnerability_status(db, vuln_hash, reference_month)
        history = VulnerabilityStatusHistory(
            vuln_hash=vuln_hash,
            month=reference_month,
            status=status
        )
        db.add(history)
    
    # Marca vulnerabilidades fechadas (que existiam no mês anterior mas não neste)
    previous_month_vulns = db.query(Vulnerability).filter(
        Vulnerability.reference_month != reference_month
    ).all()
    
    for prev_vuln in previous_month_vulns:
        if prev_vuln.vuln_hash not in processed_hashes:
            # Verifica se não já foi marcada como fechada
            existing_closed = db.query(VulnerabilityStatusHistory).filter(
                VulnerabilityStatusHistory.vuln_hash == prev_vuln.vuln_hash,
                VulnerabilityStatusHistory.month == reference_month,
                VulnerabilityStatusHistory.status == "closed"
            ).first()
            
            if not existing_closed:
                history = VulnerabilityStatusHistory(
                    vuln_hash=prev_vuln.vuln_hash,
                    month=reference_month,
                    status="closed"
                )
                db.add(history)
    
    db.commit()


def delete_by_month(db: Session, month: str):
    # Remove vulnerabilidades do mês
    db.query(Vulnerability).filter(Vulnerability.reference_month == month).delete()
    # Remove histórico do mês
    db.query(VulnerabilityStatusHistory).filter(VulnerabilityStatusHistory.month == month).delete()
    db.commit()


def delete_all(db: Session):
    db.query(Vulnerability).delete()
    db.query(VulnerabilityStatusHistory).delete()
    db.commit()


def list_vulnerabilities(db: Session, skip: int = 0, limit: int = 100):
    return db.query(Vulnerability).offset(skip).limit(limit).all()


def get_vulnerability_history(db: Session, vuln_hash: str):
    """Retorna histórico de uma vulnerabilidade específica"""
    return db.query(VulnerabilityStatusHistory).filter(
        VulnerabilityStatusHistory.vuln_hash == vuln_hash
    ).order_by(VulnerabilityStatusHistory.month).all()


def get_dashboard_stats(db: Session) -> Dict[str, Any]:
    """Retorna estatísticas completas para dashboard"""
    
    # Total de vulnerabilidades
    total_vulns = db.query(func.count(Vulnerability.id)).scalar()
    
    # Contagem por status
    status_counts = db.query(
        Vulnerability.status,
        func.count(Vulnerability.id)
    ).group_by(Vulnerability.status).all()
    
    total_by_status = {status: count for status, count in status_counts}
    
    # Contagem por severidade
    severity_counts = db.query(
        Vulnerability.severity,
        func.count(Vulnerability.id)
    ).group_by(Vulnerability.severity).all()
    
    total_by_severity = {severity: count for severity, count in severity_counts}
    
    # Contagem por mês
    month_counts = db.query(
        Vulnerability.reference_month,
        func.count(Vulnerability.id)
    ).group_by(Vulnerability.reference_month).order_by(Vulnerability.reference_month).all()
    
    total_by_month = {month: count for month, count in month_counts}
    
    # Top vulnerabilidades (mais frequentes)
    top_vulns = db.query(
        Vulnerability.nvt_name,
        func.count(Vulnerability.id).label('count'),
        Vulnerability.severity,
        func.count(func.distinct(Vulnerability.ip)).label('affected_hosts')
    ).group_by(Vulnerability.nvt_name, Vulnerability.severity)\
     .order_by(desc('count'))\
     .limit(10).all()
    
    top_vulnerabilities = [
        {
            "nvt_name": vuln.nvt_name,
            "count": vuln.count,
            "severity": vuln.severity,
            "affected_hosts": vuln.affected_hosts
        }
        for vuln in top_vulns
    ]
    
    # Atividade recente (últimos 6 meses)
    recent_months = db.query(Vulnerability.reference_month)\
        .distinct()\
        .order_by(desc(Vulnerability.reference_month))\
        .limit(6).all()
    
    recent_activity = []
    for month_data in recent_months:
        month = month_data[0]
        month_stats = db.query(
            Vulnerability.status,
            func.count(Vulnerability.id)
        ).filter(Vulnerability.reference_month == month)\
         .group_by(Vulnerability.status).all()
        
        activity = {
            "month": month,
            "new_count": 0,
            "ongoing_count": 0,
            "reopened_count": 0,
            "closed_count": 0
        }
        
        for status, count in month_stats:
            if status == "new":
                activity["new_count"] = count
            elif status == "ongoing":
                activity["ongoing_count"] = count
            elif status == "reopened":
                activity["reopened_count"] = count
            elif status == "closed":
                activity["closed_count"] = count
        
        recent_activity.append(activity)
    
    return {
        "total_vulnerabilities": total_vulns,
        "total_by_status": total_by_status,
        "total_by_severity": total_by_severity,
        "total_by_month": total_by_month,
        "top_vulnerabilities": top_vulnerabilities,
        "recent_activity": recent_activity
    }


def get_status_counts(db: Session) -> Dict[str, int]:
    """Retorna contagem por status"""
    status_counts = db.query(
        Vulnerability.status,
        func.count(Vulnerability.id)
    ).group_by(Vulnerability.status).all()
    
    return {status: count for status, count in status_counts}


def get_severity_counts(db: Session) -> Dict[str, int]:
    """Retorna contagem por severidade"""
    severity_counts = db.query(
        Vulnerability.severity,
        func.count(Vulnerability.id)
    ).group_by(Vulnerability.severity).all()
    
    return {severity: count for severity, count in severity_counts}


def get_month_counts(db: Session) -> Dict[str, int]:
    """Retorna contagem por mês"""
    month_counts = db.query(
        Vulnerability.reference_month,
        func.count(Vulnerability.id)
    ).group_by(Vulnerability.reference_month)\
     .order_by(Vulnerability.reference_month).all()
    
    return {month: count for month, count in month_counts}


def get_top_vulnerabilities(db: Session, limit: int = 10) -> List[Dict[str, Any]]:
    """Retorna top vulnerabilidades mais frequentes"""
    top_vulns = db.query(
        Vulnerability.nvt_name,
        func.count(Vulnerability.id).label('count'),
        Vulnerability.severity,
        func.count(func.distinct(Vulnerability.ip)).label('affected_hosts')
    ).group_by(Vulnerability.nvt_name, Vulnerability.severity)\
     .order_by(desc('count'))\
     .limit(limit).all()
    
    return [
        {
            "nvt_name": vuln.nvt_name,
            "count": vuln.count,
            "severity": vuln.severity,
            "affected_hosts": vuln.affected_hosts
        }
        for vuln in top_vulns
    ]


def get_recent_activity(db: Session, months: int = 6) -> List[Dict[str, Any]]:
    """Retorna atividade recente por mês"""
    recent_months = db.query(Vulnerability.reference_month)\
        .distinct()\
        .order_by(desc(Vulnerability.reference_month))\
        .limit(months).all()
    
    recent_activity = []
    for month_data in recent_months:
        month = month_data[0]
        month_stats = db.query(
            Vulnerability.status,
            func.count(Vulnerability.id)
        ).filter(Vulnerability.reference_month == month)\
         .group_by(Vulnerability.status).all()
        
        activity = {
            "month": month,
            "new_count": 0,
            "ongoing_count": 0,
            "reopened_count": 0,
            "closed_count": 0
        }
        
        for status, count in month_stats:
            if status == "new":
                activity["new_count"] = count
            elif status == "ongoing":
                activity["ongoing_count"] = count
            elif status == "reopened":
                activity["reopened_count"] = count
            elif status == "closed":
                activity["closed_count"] = count
        
        recent_activity.append(activity)
    
    return recent_activity
