from typing import List, Dict, Any
from fastapi import UploadFile, HTTPException
from sqlalchemy.orm import Session
from sqlalchemy import func, desc, String, Text, Float, Integer
import pandas as pd
from datetime import datetime
import hashlib
import json

from app.models.vulnerability import Vulnerability, VulnerabilityStatusHistory, ScanTemplate, VulnerabilityManualChangeHistory
from app.services import template as template_service


def get_months(db: Session) -> List[str]:
    result = db.query(Vulnerability.reference_month).distinct().all()
    return [row[0] for row in result]


def generate_vuln_hash(ip: str, hostname: str, nvt_name: str, cves: str) -> str:
    """Gera hash determinístico para identificar vulnerabilidades únicas"""
    # Normaliza os dados para garantir consistência
    ip = str(ip).strip()
    hostname = str(hostname).strip() if hostname else ""
    nvt_name = str(nvt_name).strip()
    cves = str(cves).strip() if cves else ""
    
    # Ordena CVEs para garantir consistência
    if cves:
        cve_list = sorted([cve.strip() for cve in cves.split(',')])
        cves = ','.join(cve_list)
    
    # Cria string para hash
    hash_string = f"{ip}|{hostname}|{nvt_name}|{cves}"
    return hashlib.sha256(hash_string.encode()).hexdigest()


def determine_vulnerability_status(db: Session, vuln_hash: str, reference_month: str) -> str:
    """Determina o status da vulnerabilidade baseado no histórico"""
    # Busca vulnerabilidades anteriores
    previous_vulns = db.query(Vulnerability).filter(
        Vulnerability.vuln_hash == vuln_hash,
        Vulnerability.reference_month != reference_month
    ).order_by(Vulnerability.reference_month.desc()).all()
    
    if not previous_vulns:
        return "new"
    
    # Busca o mês mais recente anterior
    latest_month = max([v.reference_month for v in previous_vulns])
    
    # Verifica se existia no mês anterior
    previous_month_vuln = db.query(Vulnerability).filter(
        Vulnerability.vuln_hash == vuln_hash,
        Vulnerability.reference_month == latest_month
    ).first()
    
    if previous_month_vuln:
        return "ongoing"
    else:
        return "reopened"


def save_csv(db: Session, file: UploadFile, reference_month: str, template_id: int):
    """Salva CSV usando template para mapeamento"""
    # Busca template
    template = template_service.get_template(db, template_id)
    if not template:
        raise HTTPException(status_code=404, detail="Template not found")

    try:
        df = pd.read_csv(file.file)
        print(f"CSV carregado com {len(df)} linhas e colunas: {list(df.columns)}")
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Erro ao ler CSV: {str(e)}")
    
    # Valida mapeamento do template
    errors, warnings = validate_template_mapping(template, df.columns)
    
    if errors:
        error_msg = "Erros de mapeamento do template:\n" + "\n".join(errors)
        print(f"❌ {error_msg}")
        raise HTTPException(status_code=400, detail=error_msg)
    
    if warnings:
        warning_msg = "Avisos de mapeamento:\n" + "\n".join(warnings)
        print(f"⚠️ {warning_msg}")
    
    # Aplica mapeamento de colunas
    column_mapping = template.column_mapping
    severity_map = template.severity_map
    
    # Renomeia colunas conforme template
    df = df.rename(columns=column_mapping)
    
    # Lista para armazenar hashes processados neste upload
    processed_hashes = set()
    processed_count = 0
    skipped_count = 0
    
    print(f"Processando {len(df)} linhas do CSV...")
    
    for index, row in df.iterrows():
        try:
            # Extrai dados das colunas mapeadas - corrigido para extrair valores corretamente
            ip = str(row["ip"]).strip() if pd.notna(row["ip"]) else ""
            hostname = str(row["hostname"]).strip() if pd.notna(row["hostname"]) else ""
            port = int(row["port"]) if "port" in df.columns and pd.notna(row["port"]) else None
            nvt_name = str(row["nvt_name"]).strip() if pd.notna(row["nvt_name"]) else ""
            cves = str(row["cves"]).strip() if pd.notna(row["cves"]) else ""
            cvss = row["cvss"] if pd.notna(row["cvss"]) else None
            summary = str(row["summary"]).strip() if "summary" in df.columns and pd.notna(row["summary"]) else None
            impact = str(row["impact"]).strip() if "impact" in df.columns and pd.notna(row["impact"]) else None
            solution = str(row["solution"]).strip() if "solution" in df.columns and pd.notna(row["solution"]) else None
            affects = str(row["affects"]).strip() if "affects" in df.columns and pd.notna(row["affects"]) else None
            parameter = str(row["parameter"]).strip() if "parameter" in df.columns and pd.notna(row["parameter"]) else None
            request_col = str(row["request"]).strip() if "request" in df.columns and pd.notna(row["request"]) else None
            raw_text_details = str(row["raw_text_details"]).strip() if "raw_text_details" in df.columns and pd.notna(row["raw_text_details"]) else None
            
            # Normaliza severidade
            raw_severity = str(row["severity"]).strip().lower() if pd.notna(row["severity"]) else ""
            severity = severity_map.get(raw_severity, raw_severity)
            
            # Gera hash
            vuln_hash = generate_vuln_hash(ip, hostname, nvt_name, cves)
            
            # Determina status
            status = determine_vulnerability_status(db, vuln_hash, reference_month)
            
            # Valida e limpa os dados antes de criar a vulnerabilidade
            if not ip or ip == "nan" or len(ip) > 45:
                skipped_count += 1
                continue  # Pula registros com IP inválido
            
            if not nvt_name or nvt_name == "nan":
                skipped_count += 1
                continue  # Pula registros sem nome de vulnerabilidade
            
            # Limita tamanho dos campos conforme definido no modelo
            ip = ip[:45] if len(ip) > 45 else ip
            hostname = hostname[:255] if hostname and len(hostname) > 255 else hostname
            parameter = parameter[:255] if parameter and len(parameter) > 255 else parameter
            nvt_name = nvt_name[:1000] if len(nvt_name) > 1000 else nvt_name  # Limite para TEXT
            severity = severity[:20] if len(severity) > 20 else severity
            
            # Converte CVSS para float se possível
            try:
                cvss_float = float(cvss) if cvss is not None and cvss != "nan" else None
            except (ValueError, TypeError):
                cvss_float = None
            
            # Cria vulnerabilidade
            vuln = Vulnerability(
                ip=ip,
                hostname=hostname if hostname and hostname != "nan" else None,
                port=port,
                nvt_name=nvt_name,
                severity=severity,
                cvss=cvss_float,
                cves=cves if cves and cves != "nan" else None,
                summary=summary,
                impact=impact,
                solution=solution,
                affects=affects,
                parameter=parameter,
                request=request_col,
                raw_text_details=raw_text_details,
                reference_month=reference_month,
                vuln_hash=vuln_hash,
                status=status,
                original_severity=severity,  # Guarda a severidade original
                severity_manually_changed=False,  # Não foi alterada manualmente
                original_status=status,  # Guarda o status original
                status_manually_changed=False  # Não foi alterado manualmente
            )
            
            db.add(vuln)
            processed_hashes.add(vuln_hash)
            processed_count += 1
            
        except Exception as e:
            print(f"Erro ao processar linha {index}: {e}")
            skipped_count += 1
            continue
    
    print(f"Processamento concluído: {processed_count} processadas, {skipped_count} ignoradas")
    
    # Registra histórico de status
    for vuln_hash in processed_hashes:
        status = determine_vulnerability_status(db, vuln_hash, reference_month)
        history = VulnerabilityStatusHistory(
            vuln_hash=vuln_hash,
            month=reference_month,
            status=status
        )
        db.add(history)
    
    # Marca vulnerabilidades fechadas (que existiam no mês anterior mas não neste)
    previous_month_vulns = db.query(Vulnerability).filter(
        Vulnerability.reference_month != reference_month
    ).all()
    
    for prev_vuln in previous_month_vulns:
        if prev_vuln.vuln_hash not in processed_hashes:
            # Verifica se não já foi marcada como fechada
            existing_closed = db.query(VulnerabilityStatusHistory).filter(
                VulnerabilityStatusHistory.vuln_hash == prev_vuln.vuln_hash,
                VulnerabilityStatusHistory.month == reference_month,
                VulnerabilityStatusHistory.status == "closed"
            ).first()
            
            if not existing_closed:
                history = VulnerabilityStatusHistory(
                    vuln_hash=prev_vuln.vuln_hash,
                    month=reference_month,
                    status="closed"
                )
                db.add(history)
    
    db.commit()


def delete_by_month(db: Session, month: str):
    # Remove vulnerabilidades do mês
    db.query(Vulnerability).filter(Vulnerability.reference_month == month).delete()
    # Remove histórico do mês
    db.query(VulnerabilityStatusHistory).filter(VulnerabilityStatusHistory.month == month).delete()
    db.commit()


def delete_all(db: Session):
    db.query(Vulnerability).delete()
    db.query(VulnerabilityStatusHistory).delete()
    db.commit()


def list_vulnerabilities(db: Session, skip: int = 0, limit: int = 100):
    return db.query(Vulnerability).offset(skip).limit(limit).all()


def get_vulnerability_history(db: Session, vuln_hash: str):
    """Retorna histórico de uma vulnerabilidade específica"""
    return db.query(VulnerabilityStatusHistory).filter(
        VulnerabilityStatusHistory.vuln_hash == vuln_hash
    ).order_by(VulnerabilityStatusHistory.month).all()


def get_dashboard_stats(db: Session) -> Dict[str, Any]:
    """Retorna estatísticas completas para dashboard"""
    
    # Total de vulnerabilidades
    total_vulns = db.query(func.count(Vulnerability.id)).scalar()
    
    # Contagem por status
    status_counts = db.query(
        Vulnerability.status,
        func.count(Vulnerability.id)
    ).group_by(Vulnerability.status).all()
    
    total_by_status = {status: count for status, count in status_counts}
    
    # Contagem por severidade
    severity_counts = db.query(
        Vulnerability.severity,
        func.count(Vulnerability.id)
    ).group_by(Vulnerability.severity).all()
    
    total_by_severity = {severity: count for severity, count in severity_counts}
    
    # Contagem por mês
    month_counts = db.query(
        Vulnerability.reference_month,
        func.count(Vulnerability.id)
    ).group_by(Vulnerability.reference_month).order_by(Vulnerability.reference_month).all()
    
    total_by_month = {month: count for month, count in month_counts}
    
    # Top vulnerabilidades (mais frequentes)
    top_vulns = db.query(
        Vulnerability.nvt_name,
        func.count(Vulnerability.id).label('count'),
        Vulnerability.severity,
        func.count(func.distinct(Vulnerability.ip)).label('affected_hosts')
    ).group_by(Vulnerability.nvt_name, Vulnerability.severity)\
     .order_by(desc('count'))\
     .limit(10).all()
    
    top_vulnerabilities = [
        {
            "nvt_name": vuln.nvt_name,
            "count": vuln.count,
            "severity": vuln.severity,
            "affected_hosts": vuln.affected_hosts
        }
        for vuln in top_vulns
    ]
    
    # Atividade recente (últimos 6 meses)
    recent_months = db.query(Vulnerability.reference_month)\
        .distinct()\
        .order_by(desc(Vulnerability.reference_month))\
        .limit(6).all()
    
    recent_activity = []
    for month_data in recent_months:
        month = month_data[0]
        month_stats = db.query(
            Vulnerability.status,
            func.count(Vulnerability.id)
        ).filter(Vulnerability.reference_month == month)\
         .group_by(Vulnerability.status).all()
        
        activity = {
            "month": month,
            "new_count": 0,
            "ongoing_count": 0,
            "reopened_count": 0,
            "closed_count": 0
        }
        
        for status, count in month_stats:
            if status == "new":
                activity["new_count"] = count
            elif status == "ongoing":
                activity["ongoing_count"] = count
            elif status == "reopened":
                activity["reopened_count"] = count
            elif status == "closed":
                activity["closed_count"] = count
        
        recent_activity.append(activity)
    
    return {
        "total_vulnerabilities": total_vulns,
        "total_by_status": total_by_status,
        "total_by_severity": total_by_severity,
        "total_by_month": total_by_month,
        "top_vulnerabilities": top_vulnerabilities,
        "recent_activity": recent_activity
    }


def get_status_counts(db: Session) -> Dict[str, int]:
    """Retorna contagem por status"""
    status_counts = db.query(
        Vulnerability.status,
        func.count(Vulnerability.id)
    ).group_by(Vulnerability.status).all()
    
    return {status: count for status, count in status_counts}


def get_severity_counts(db: Session) -> Dict[str, int]:
    """Retorna contagem por severidade"""
    severity_counts = db.query(
        Vulnerability.severity,
        func.count(Vulnerability.id)
    ).group_by(Vulnerability.severity).all()
    
    return {severity: count for severity, count in severity_counts}


def get_month_counts(db: Session) -> Dict[str, int]:
    """Retorna contagem por mês"""
    month_counts = db.query(
        Vulnerability.reference_month,
        func.count(Vulnerability.id)
    ).group_by(Vulnerability.reference_month)\
     .order_by(Vulnerability.reference_month).all()
    
    return {month: count for month, count in month_counts}


def get_top_vulnerabilities(db: Session, limit: int = 10) -> List[Dict[str, Any]]:
    """Retorna top vulnerabilidades mais frequentes"""
    top_vulns = db.query(
        Vulnerability.nvt_name,
        func.count(Vulnerability.id).label('count'),
        Vulnerability.severity,
        func.count(func.distinct(Vulnerability.ip)).label('affected_hosts')
    ).group_by(Vulnerability.nvt_name, Vulnerability.severity)\
     .order_by(desc('count'))\
     .limit(limit).all()
    
    return [
        {
            "nvt_name": vuln.nvt_name,
            "count": vuln.count,
            "severity": vuln.severity,
            "affected_hosts": vuln.affected_hosts
        }
        for vuln in top_vulns
    ]


def get_recent_activity(db: Session, months: int = 6) -> List[Dict[str, Any]]:
    """Retorna atividade recente por mês"""
    recent_months = db.query(Vulnerability.reference_month)\
        .distinct()\
        .order_by(desc(Vulnerability.reference_month))\
        .limit(months).all()
    
    recent_activity = []
    for month_data in recent_months:
        month = month_data[0]
        month_stats = db.query(
            Vulnerability.status,
            func.count(Vulnerability.id)
        ).filter(Vulnerability.reference_month == month)\
         .group_by(Vulnerability.status).all()
        
        activity = {
            "month": month,
            "new_count": 0,
            "ongoing_count": 0,
            "reopened_count": 0,
            "closed_count": 0
        }
        
        for status, count in month_stats:
            if status == "new":
                activity["new_count"] = count
            elif status == "ongoing":
                activity["ongoing_count"] = count
            elif status == "reopened":
                activity["reopened_count"] = count
            elif status == "closed":
                activity["closed_count"] = count
        
        recent_activity.append(activity)
    
    return recent_activity


def validate_template_mapping(template, df_columns):
    """Valida se o template tem mapeamento correto para as colunas do CSV"""
    errors = []
    warnings = []
    
    # Verifica se todas as colunas necessárias estão mapeadas
    required_mappings = ['ip', 'nvt_name', 'severity']
    missing_mappings = []
    
    for required in required_mappings:
        if required not in template.column_mapping.values():
            missing_mappings.append(required)
    
    if missing_mappings:
        errors.append(f"Template não mapeia colunas obrigatórias: {missing_mappings}")
    
    # Verifica se as colunas do CSV existem no mapeamento
    csv_columns = set(df_columns)
    mapped_columns = set(template.column_mapping.keys())
    
    missing_csv_columns = mapped_columns - csv_columns
    if missing_csv_columns:
        errors.append(f"Colunas mapeadas não encontradas no CSV: {missing_csv_columns}")
    
    # Verifica mapeamentos duplicados (múltiplas colunas CSV → mesma coluna DB)
    db_columns = list(template.column_mapping.values())
    duplicates = [col for col in set(db_columns) if db_columns.count(col) > 1]
    if duplicates:
        warnings.append(f"Mapeamentos duplicados detectados: {duplicates}")
    
    # Verifica colunas opcionais adicionais para orientar o usuário
    optional_supported = {"hostname", "port", "summary", "impact", "solution", "affects", "parameter", "request", "raw_text_details", "cvss", "cves"}
    present_optional = sorted(list(optional_supported.intersection(csv_columns)))
    if present_optional:
        warnings.append(f"Colunas opcionais detectadas que podem ser mapeadas: {present_optional}")
    
    return errors, warnings


def get_expected_fields():
    """Retorna os campos esperados para upload de vulnerabilidades baseado na estrutura real da tabela"""
    from app.schemas.vulnerability import ExpectedField, ExpectedFieldsResponse
    from app.models.vulnerability import Vulnerability
    from sqlalchemy import inspect
    
    # Obtém informações da tabela Vulnerability usando reflection
    inspector = inspect(Vulnerability)
    columns = inspector.columns
    
    # Define campos que são preenchidos automaticamente (não vêm do CSV)
    auto_fields = {'id', 'created_at', 'vuln_hash', 'status', 'reference_month', 'original_severity', 'severity_manually_changed', 'original_status', 'status_manually_changed'}
    
    # Define campos obrigatórios baseado na estrutura da tabela
    required_fields = []
    optional_fields = []
    
    for column in columns:
        column_name = column.name
        
        # Pula campos que são preenchidos automaticamente
        if column_name in auto_fields:
            continue
            
        # Determina se é obrigatório baseado na estrutura da tabela
        is_required = not column.nullable
        
        # Mapeia tipos SQL para tipos de dados mais amigáveis
        if isinstance(column.type, String):
            data_type = "string"
            max_length = column.type.length if hasattr(column.type, 'length') else None
        elif isinstance(column.type, Text):
            data_type = "string"
            max_length = None
        elif isinstance(column.type, Float):
            data_type = "float"
            max_length = None
        elif isinstance(column.type, Integer):
            data_type = "integer"
            max_length = None
        else:
            data_type = "string"
            max_length = None
        
        # Cria descrição baseada no nome do campo
        descriptions = {
            'ip': 'Endereço IP do host vulnerável',
            'hostname': 'Nome do host vulnerável',
            'port': 'Porta de serviço associada à vulnerabilidade',
            'nvt_name': 'Nome da vulnerabilidade/NVT',
            'severity': 'Nível de severidade da vulnerabilidade',
            'cvss': 'Score CVSS da vulnerabilidade',
            'cves': 'Lista de CVEs separados por vírgula',
            'summary': 'Resumo da vulnerabilidade',
            'impact': 'Impacto potencial da vulnerabilidade',
            'solution': 'Solução recomendada para correção',
            'affects': 'Componentes/versões afetados',
            'parameter': 'Parâmetro afetado (quando aplicável)',
            'request': 'Requisição associada (quando aplicável)',
            'raw_text_details': 'Detalhes brutos (texto do scanner)'
        }
        
        description = descriptions.get(column_name, f'Campo {column_name}')
        
        # Adiciona informação de tamanho máximo se aplicável
        if max_length:
            description += f' (máximo {max_length} caracteres)'
        
        # Exemplos baseados no campo
        examples = {
            'ip': '192.168.1.1',
            'hostname': 'server01.example.com',
            'port': '443',
            'nvt_name': 'SQL Injection',
            'severity': 'High',
            'cvss': '8.5',
            'cves': 'CVE-2021-1234,CVE-2021-5678',
            'summary': 'Service allows weak ciphers',
            'impact': 'Remote attacker could decrypt traffic',
            'solution': 'Disable weak ciphers and update OpenSSL',
            'affects': 'OpenSSL < 1.1.1n',
            'parameter': 'username',
            'request': 'GET /login HTTP/1.1',
            'raw_text_details': 'Scanner output raw text...'
        }
        
        example = examples.get(column_name)
        
        field = ExpectedField(
            name=column_name,
            required=is_required,
            description=description,
            example=example,
            data_type=data_type
        )
        
        if is_required:
            required_fields.append(field)
        else:
            optional_fields.append(field)
    
    # Níveis de severidade aceitos
    severity_levels = [
        "Critical",
        "High", 
        "Medium",
        "Low",
        "Info"
    ]
    
    # Exemplo de mapeamento baseado em nomes comuns de colunas CSV
    example_mapping = {
        "Host": "ip",
        "IP": "ip",
        "IP Address": "ip",
        "Port": "port",
        "Name": "nvt_name",
        "Vulnerability": "nvt_name",
        "Title": "nvt_name",
        "Risk": "severity",
        "Severity": "severity",
        "Level": "severity",
        "CVSS": "cvss",
        "Score": "cvss",
        "CVE": "cves",
        "CVEs": "cves",
        "Hostname": "hostname",
        "Server": "hostname",
        "Domain": "hostname",
        "Summary": "summary",
        "Impact": "impact",
        "Solution": "solution",
        "Affects": "affects",
        "Parameter": "parameter",
        "Request": "request",
        "Raw text Details": "raw_text_details",
        "Raw Text Details": "raw_text_details",
        "Details": "raw_text_details"
    }
    
    return ExpectedFieldsResponse(
        required_fields=required_fields,
        optional_fields=optional_fields,
        severity_levels=severity_levels,
        example_mapping=example_mapping
    )


def change_vulnerability_severity(db: Session, vulnerability_id: int, new_severity: str, changed_by: str, reason: str = None):
    """Altera manualmente a severidade de uma vulnerabilidade"""
    
    # Busca a vulnerabilidade
    vuln = db.query(Vulnerability).filter(Vulnerability.id == vulnerability_id).first()
    if not vuln:
        raise HTTPException(status_code=404, detail="Vulnerability not found")
    
    # Valida a nova severidade
    valid_severities = ["Critical", "High", "Medium", "Low", "Info"]
    if new_severity not in valid_severities:
        raise HTTPException(status_code=400, detail=f"Invalid severity. Must be one of: {valid_severities}")
    
    # Verifica se já foi alterada manualmente
    old_severity = vuln.severity
    
    # Atualiza a vulnerabilidade
    vuln.severity = new_severity
    vuln.severity_manually_changed = True
    
    # Tenta registrar no histórico (opcional)
    try:
        change_history = VulnerabilityManualChangeHistory(
            vulnerability_id=vulnerability_id,
            vuln_hash=vuln.vuln_hash,
            field_changed="severity",
            old_value=old_severity,
            new_value=new_severity,
            changed_by=changed_by,
            reason=reason
        )
        db.add(change_history)
    except Exception as e:
        # Se falhar, continua sem o histórico
        print(f"Warning: Could not save manual change history: {e}")
    
    db.commit()
    db.refresh(vuln)
    
    return vuln


def change_vulnerability_severity_by_hash(db: Session, vuln_hash: str, new_severity: str, changed_by: str, reason: str = None):
    """Altera manualmente a severidade de uma vulnerabilidade usando o hash"""
    
    # Busca a vulnerabilidade pelo hash (pega a mais recente se houver múltiplas)
    vuln = db.query(Vulnerability).filter(
        Vulnerability.vuln_hash == vuln_hash
    ).order_by(Vulnerability.reference_month.desc()).first()
    
    if not vuln:
        raise HTTPException(status_code=404, detail="Vulnerability not found")
    
    # Valida a nova severidade
    valid_severities = ["Critical", "High", "Medium", "Low", "Info"]
    if new_severity not in valid_severities:
        raise HTTPException(status_code=400, detail=f"Invalid severity. Must be one of: {valid_severities}")
    
    # Verifica se já foi alterada manualmente
    old_severity = vuln.severity
    
    # Atualiza a vulnerabilidade
    vuln.severity = new_severity
    vuln.severity_manually_changed = True
    
    # Tenta registrar no histórico (opcional)
    try:
        change_history = VulnerabilityManualChangeHistory(
            vulnerability_id=vuln.id,
            vuln_hash=vuln.vuln_hash,
            field_changed="severity",
            old_value=old_severity,
            new_value=new_severity,
            changed_by=changed_by,
            reason=reason
        )
        db.add(change_history)
    except Exception as e:
        # Se falhar, continua sem o histórico
        print(f"Warning: Could not save manual change history: {e}")
    
    db.commit()
    db.refresh(vuln)
    
    return vuln


def change_vulnerability_status(db: Session, vulnerability_id: int, new_status: str, changed_by: str, reason: str = None):
    """Altera manualmente o status de uma vulnerabilidade"""
    
    # Busca a vulnerabilidade
    vuln = db.query(Vulnerability).filter(Vulnerability.id == vulnerability_id).first()
    if not vuln:
        raise HTTPException(status_code=404, detail="Vulnerability not found")
    
    # Valida o novo status
    valid_statuses = ["new", "ongoing", "reopened", "closed"]
    if new_status not in valid_statuses:
        raise HTTPException(status_code=400, detail=f"Invalid status. Must be one of: {valid_statuses}")
    
    # Verifica se já foi alterada manualmente
    old_status = vuln.status
    
    # Atualiza a vulnerabilidade
    vuln.status = new_status
    vuln.status_manually_changed = True
    
    # Tenta registrar no histórico (opcional)
    try:
        change_history = VulnerabilityManualChangeHistory(
            vulnerability_id=vulnerability_id,
            vuln_hash=vuln.vuln_hash,
            field_changed="status",
            old_value=old_status,
            new_value=new_status,
            changed_by=changed_by,
            reason=reason
        )
        db.add(change_history)
    except Exception as e:
        # Se falhar, continua sem o histórico
        print(f"Warning: Could not save manual change history: {e}")
    
    db.commit()
    db.refresh(vuln)
    
    return vuln


def change_vulnerability_status_by_hash(db: Session, vuln_hash: str, new_status: str, changed_by: str, reason: str = None):
    """Altera manualmente o status de uma vulnerabilidade usando o hash"""
    
    # Busca a vulnerabilidade pelo hash (pega a mais recente se houver múltiplas)
    vuln = db.query(Vulnerability).filter(
        Vulnerability.vuln_hash == vuln_hash
    ).order_by(Vulnerability.reference_month.desc()).first()
    
    if not vuln:
        raise HTTPException(status_code=404, detail="Vulnerability not found")
    
    # Valida o novo status
    valid_statuses = ["new", "ongoing", "reopened", "closed"]
    if new_status not in valid_statuses:
        raise HTTPException(status_code=400, detail=f"Invalid status. Must be one of: {valid_statuses}")
    
    # Verifica se já foi alterada manualmente
    old_status = vuln.status
    
    # Atualiza a vulnerabilidade
    vuln.status = new_status
    vuln.status_manually_changed = True
    
    # Tenta registrar no histórico (opcional)
    try:
        change_history = VulnerabilityManualChangeHistory(
            vulnerability_id=vuln.id,
            vuln_hash=vuln.vuln_hash,
            field_changed="status",
            old_value=old_status,
            new_value=new_status,
            changed_by=changed_by,
            reason=reason
        )
        db.add(change_history)
    except Exception as e:
        # Se falhar, continua sem o histórico
        print(f"Warning: Could not save manual change history: {e}")
    
    db.commit()
    db.refresh(vuln)
    
    return vuln


def get_vulnerability_manual_changes(db: Session, vulnerability_id: int):
    """Retorna o histórico de alterações manuais de uma vulnerabilidade"""
    from app.models.vulnerability import VulnerabilityManualChangeHistory
    
    changes = db.query(VulnerabilityManualChangeHistory).filter(
        VulnerabilityManualChangeHistory.vulnerability_id == vulnerability_id
    ).order_by(VulnerabilityManualChangeHistory.changed_at.desc()).all()
    
    return changes


def get_all_manual_changes(db: Session, skip: int = 0, limit: int = 100):
    """Retorna todas as alterações manuais com paginação"""
    from app.models.vulnerability import VulnerabilityManualChangeHistory
    
    changes = db.query(VulnerabilityManualChangeHistory).offset(skip).limit(limit).order_by(
        VulnerabilityManualChangeHistory.changed_at.desc()
    ).all()
    
    return changes
